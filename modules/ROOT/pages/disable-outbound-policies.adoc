= Disable Outbound Policy
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: policy, outbound-policies, resource-level

With Mule 4, you can now apply policies on the outgoing HTTP requests to a Mule runtime engine (Mule) application, in addition to applying policies to the incoming HTTP requests. 

Policies applied to outgoing HTTP requests are known as Outbound policies and are implemented by defining an _http-policy:operation_ block in the policy template, which specifies the execution components.

Mule then applies the operation block of every policy that is applied to an API, to every HTTP requester element defined in a  Mule application.

In the case of the HTTP proxy, there is only one HTTP Requester defined to which an outbound policy is applied.

Because more complex Mule applications that implement APIs may be invoking several external services, more than one HTTP Requesters can be defined for such APIs. In that case, outbound policies are applied to each one of the HTTP requests that the application performs.

Let’s look at an example Mule application flow implementing an API:

[Source,text,linenums]
----
<flow name="implementation">
   <http:listener config-ref="http-config" path="api"/>

   <http:request method="GET" url="http://service-1" />
   <logger message="#[payload]" level="INFO"/>
   <http:request method="POST" url="http://service-2" />
</flow>
----

Every time the Mule application is invoked, two HTTP requests to external services are executed.

Now let’s look at an example  Mule policy that is applied to the previous example application, which is adding a header to the HTTP request: 

[Source,text,linenums]
----
<http-policy:operation>
   <http-transform:add-request-headers>
       <http-transform:headers>#[{'new-header': 'the-value'}]</http-transform:headers>
   </http-transform:add-request-headers>

   <http-policy:execute-next/>
</http-policy:operation>
----

Every time theMule application is invoked, the Mule policy is executed twice: once when invoking `service-1` and the other when invoking `service-2`. Each of those HTTP requests has an additional header called `new-header`, which is added by the policy.

Now imagine that `service-1` needs the additional header for authentication purposes, but service-2 is very restrictive and rejects incoming requests that have unexpected headers like the one added by the policy.

With Mule 4.3.0, this scenario can be implemented. By specifying the annotation `api-gateway:disablePolicies="true"` in any of the HTTP requesters that a Mule application has defined, the Mule policy engine avoids executing policies for that annotated requester.

When using the annotation, the following namespace must be specified in the application:

`xmlns:api-gateway="http://www.mulesoft.org/schema/mule/api-gateway"`

Continuing with the example, to achieve this, the application flow must like the following:

[Source, text, linenums]
----
<flow name="implementation">
   <http:listener config-ref="http-config" path="api"/>

   <http:request method="GET" url="http://service-1" />
   <logger message="#[payload]" level="INFO"/>
   <http:request method="POST" url="http://service-2" api-gateway:disablePolicies="true" />
</flow>
----

By specifying the annotation on the HTTP requester that invokes `service-2`, the policy is not applied. Therefore, the additional header is not appended to that particular HTTP request.

If a Mule application with the annotation is deployed to a Mule version prior to 4.3.0, it has no effect and the policies are not disabled. However, the application is still deployed.


== See Also

* xref:policies-mule4.adoc[Policies for Mule 4]


