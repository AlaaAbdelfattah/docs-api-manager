= Policies Overview
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]
:keywords: policy, custom, ootb, offline

Policies differ based on several different factors, such as level of granularity,types of policies, and policy categories. You must carefully review these factors, before you decide to implementation them in your environment. In this section, each of these factors are explained in detail. 

== Policy Components

A policy consists of the following components:

* YAML file
+
Defines the configurable parameters of the policy. Rendered by the UI to display the input of the policy.
+
* XML template
+
Contains the implementation of the policy.
* Template's POM
+
Defines policy dependencies. Packaging type needs to be `mule-policy`.
* Resources
+
Optionally if the policy depends on other resources, such as a certificate, define resources as part of the policy.
+
* Mule-artifact.json descriptor
+
Specify the classifier as `mule-policy`.

For more information, see the header policy.

== Policy Scope

Policies are isolated from the application and other policies. However, there are ways to expose information from a policy. The authentication information about a policy can be propagated in the Security Context Principal object.

A policy can modify message content. In Mule 4.1.0 and later, if the message is modified before the `execute-next` in `source` policies
or after it in `operation` policies, those modifications are not propagated by default. To enable propagation of those modifications
you can enable the `propagateMessageTransformations` flag in each policy.

*Example*

----
<http-policy:proxy name="scope-payload">
    <http-policy:source propagateMessageTransformations="true">

        <http-policy:execute-next/>

    </http-policy:source>
    <http-policy:operation propagateMessageTransformations="true">

        <http-policy:execute-next/>

    </http-policy:operation>
</http-policy:proxy>
----

A policy can avoid the execution of the flow by not defining the `execute-next` or making sure that it is not reached (placing it in a choice, for example).

Variables set on a policy have only the scope of the policy. Also, variables defined in the flow, are not visible in policies.

== Policy Size

The size of a policy varies based on its dependencies. The first time Mule Runtime polls for policies it will take longer to fetch them. However, after policies are retrieved, they are cached on the file system. This ensures offline availability and also reduces latency to fetch policies.


== RAML and OAS-Based APIs
[PA Why do we need this section. We have one about how to build RAML and OAS APIs.]

If your API exposes a RAML or OAS definition that users might need to reference, then the API definition must reliably detail every element that is expected in calls to your API. +
For example, applying a client ID-based policies implies that all requests coming to your API include a client ID and client Secret (by default expected as query parameters). You can prevent user requests from being rejected by creating a trait in the RAML root, and then referencing this trait in all API operations. 

Example: Create a trait that request APIs to provide Client ID and Client Secret paramters
[source,yaml,linenums]
----
traits:
  - client-id-required:
      queryParameters:
        client_id:
          type: string
        client_secret:
          type: string
----

Ezampl: Apply the trait in API operationss:

[source,yaml,linenums]
----
/products:
  get:
    is: [client-id-required]
    description: Gets a list of all the inventory products.
----


This section covers the following topics:

== See Also

* xref:policies-mule3.adoc[Policies in Mule 3]
* xref:policies-mule4.adoc[Policies in Mule 4]
